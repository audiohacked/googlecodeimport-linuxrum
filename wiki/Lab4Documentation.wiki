#summary This is where our documentation for the final lab goes.

= Introduction =
Lab 4 is about memory management. Specifically pages. Part I deals with reporting memory management statistics. Part II deals with replacing the page replacement algorithm.


= Part I =
We decided to call the directory that contains our system call 'rum', since that's the name of our group. We called the function itself mem_stats, and it returns an int pointer, which in turn has 7 values, each corresponding to those required in the lab.

Also added rum/ to the core-y          += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ 
line in the Makefile in the top level of the kernel, line 555. Then added a Makefile to the rum/ directory with the following contents:

`obj-y   := mem_stats.o`

Then we added the following lines to include/asm-x86-64/unistd.h:

`#define __NR_mem_stats          280`

`__SYSCALL(__NR_mem_stats, sys_mem_stats)`

In order to get the statistics from memory, we investigated `get_zone_counts` and `__get_zone_counts` in mm/vmstat.c, line 17 and 33, respectively; these functions get the number of active, inactive, and free pages from each zone. This in turn led us to the zone struct, which is locate in include/linux/mmzone.h, line 139. The `get_zone_counts` function uses 

{{{

for_each_online_pgdat(pgdat){
	unsigned long l, m, n;
	__get_zone_counts(&l, &m, &n, pgdat);
	*active += l;
	*inactive += m;
	*free += n;
} 

}}}

to iterate through the zones of each pgdat, using:

{{{
void __get_zone_counts(unsigned long *active, unsigned long *inactive,
			unsigned long *free, struct pglist_data *pgdat)
{
	struct zone *zones = pgdat->node_zones;
	int i;

	*active = 0;
	*inactive = 0;
	*free = 0;
	for (i = 0; i < MAX_NR_ZONES; i++) {
		*active += zones[i].nr_active;
		*inactive += zones[i].nr_inactive;
		*free += zones[i].free_pages;
	}
}
}}}

I adopted the code from that function with:

{{{
void __mem_stats(unsigned long *stats, struct pglist_data *pgdat)
{
	struct zone *zones = pgdat->node_zones;
	int i;

	stats[0] = 0;
	stats[1] = 0;
	stats[5] = 0;
	for (i = 0; i < MAX_NR_ZONES; i++) {
		stats[0] += zones[i].nr_active;
		stats[1] += zones[i].nr_inactive;
		stats[5] += zones[i].free_pages;
	}
}


asmlinkage int sys_mem_stats(void __user *to, void __user *from, int n)
{
	struct pglist_data *pgdat;
	// stats is the data to be returned, tempStats is for 
	unsigned long *stats, *tempStats;
	stats = kmalloc(sizeof(unsigned long)*7,GFP_KERNEL);
	tempStats = kmalloc(sizeof(unsigned long)*7,GFP_KERNEL);
	
	// initialize counts to zero
	// stats[0] is the active pages
	// stats[1] is the inactive pages
	// stats[6] is inactive + active
	stats[0] = 0;
	stats[1] = 0;
	stats[6] = 0;
	
	// iterate through higher level memory zones,
	// (if they exist)
	for_each_online_pgdat(pgdat) {
		// __mem_stats looks at each zone, and
		// counts the number of acive and inactive
		// frames
		__mem_stats(tempStats, pgdat);
		
		stats[0] += tempStats[0];
		stats[1] += tempStats[1];
		stats[6] += tempStats[0] + tempStats[1];
	}

	kfree(tempStats);
	copy_to_user((void *)to, (void *)stats, sizeof(unsigned long)*7);
	//to = stats;
	return 0;
}
}}}

= Part II =

Scanning code for reference count:

Within shrink_active_list, it isolates all of LRU pages to a holding list. It loops through the list. For each page, there's a reference count. For each page that's referenced, our code increments ref_count, which holds the reference count for the page. The function called page_referenced will check if the reference bit flag of the page is set, and if it is, it adds it to the reference count. Then, after that, it removes the page from the zone's active list. It'll check if the page is mapped, and if so, it does another check to reclaim.